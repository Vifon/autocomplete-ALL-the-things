#!/usr/bin/perl
#########################################################################
# Copyright (C) 2012-2013  Wojciech Siewierski                          #
#                                                                       #
# This program is free software: you can redistribute it and/or modify  #
# it under the terms of the GNU General Public License as published by  #
# the Free Software Foundation, either version 3 of the License, or     #
# (at your option) any later version.                                   #
#                                                                       #
# This program is distributed in the hope that it will be useful,       #
# but WITHOUT ANY WARRANTY; without even the implied warranty of        #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         #
# GNU General Public License for more details.                          #
#                                                                       #
# You should have received a copy of the GNU General Public License     #
# along with this program.  If not, see <http://www.gnu.org/licenses/>. #
#########################################################################


sub on_user_command {
    my ($self, $cmd) = @_;

    if ($cmd eq 'aAtt:complete') {
        # if the last action was a completion, undo it
        if (exists $self->{last_word}) {
            replace_text($self, $self->{last_completion}, $self->{last_word});
        } else {
            my ($row, $col) = $self->screen_cur; # get cursor coordinates
            my $word_to_complete = get_current_word($self, $row, $col); # read the word behind the cursor

            if ($word_to_complete) {
                my $completion = find_match($self, $word_to_complete, $row);
                if ($completion) {
                    # save the last completed word
                    $self->{last_word}       = $word_to_complete;
                    # save the last completion
                    $self->{last_completion} = $completion;

                    replace_text($self, $word_to_complete, $completion);
                }
            }
            return 1;
        }
    }

    # forget the last completion on any command other than aAtt:complete
    delete $self->{last_word};
    delete $self->{last_completion};

    ()
}

sub on_key_press {
    my ($self, $event, $keysym) = @_;

    # forget the last completion when the user presses any ASCII key
    if ($keysym <= 127) { # if ASCII
        delete $self->{last_word};
        delete $self->{last_completion};
    }

    ()
}

######################################################################

sub replace_text {
    my ($self, $current_text, $replacement) = @_;

    # "press" backspace to erase the text; probably not portable
    $self->tt_paste($self->locale_encode("" x length $current_text));

    # print out the replacement
    $self->tt_write($self->locale_encode($replacement));
}

######################################################################

sub get_current_word {
    my ($self, $row, $col) = @_;

    $_ = substr($self->ROW_t($row), 0, $col); # get the current line up to the cursor
    s/.*?(\S*)$/$1/;                          # and read the last word from it
    return $_;
}

######################################################################

# See: https://github.com/baohaojun/skeleton-complete
sub skeleton_to_regex {
    $_ = shift;

    # sorry for this lispy code, I couldn't resist ;)
    (join ".*?",
     (map quotemeta,
      (split //)))
}

######################################################################

sub find_match {
    my ($self, $word_to_match, $current_row) = @_;

    my $regexp = skeleton_to_regex($word_to_match);

    # iterate throughout all the rows starting with one above the cursor
    for (my $i = $current_row-1; $i >= 0; --$i) {
        $_ = $self->ROW_t($i);   # get the line of text from the row
        if (/.*($regexp\w*)/i) { # and check if there is a match
            return $1;
        }
    }
    return undef;
}
